TODO:
**// Track current date and increment each time we successfully complete batch process
**// Method to 'fake date' for testing refills = **// Set system date
**// RECONCILE ALL NAMES W/ FIND&REPLACE
**// TYPE CONVERSION:  String to whatever type
**// CONVERSION FUNCTIONS FOR Event DATA STRUCTURES
**// "STORE" - IMPLIES TYPE CONVERSION, THIS NEEDS TO BE DONE
**// AddDeleteStore -- Populate price with randomly generated # between 1.0-40.0
**// Add warehouse item functionality in online portion pending on Steiner response
			// *NOTE*:  ONLY TRIM SPACES WHEN EVALUATING... EX:  SEARCH, MATCH, ETC.
			DO IF TIME:
			// *NOTE*:  ONLY UPPERCASE WHEN EVALUATING... EX:  SEARCH, MATCH, ETC.
**// Anywhere an item gets added, set:
		// High Threshold = 1.15 * reorder_level
		// Low Threshold = 0.85 * reorder_level
**// Implement 'empty months' in sales reports
			
			
Offline Batch Process:
5.  Run Offline Batch Process
	
	void runOfflineBatchProcess
	{		
			For each store in store_table
				If store_status is 'O'
					Display error message
					Log warning message
					Return to main menu
	
		ReturnValue = AddDeleteStore(warehouse_item_data, store_data, etc)
		if (AddDeleteStore == 1)
			Log Error "Finished processing AddDeleteStore with Errors"
		if (AddDeleteStore == -1)
			Log Error "CRITICAL ERROR - SEQUENCE CHECK FAILED"
			break
		if (AddDeleteStore == 0)
			Log "AddDeleteStore completed successfully"
		
		.
		.
		.
		
		MergeValue = Merge(...)
		if (Merge == 1)
		
		
	}
		
	int AddDeleteStore(&table1, &table2, etc)
	
		// Critical error
			return -1
		// Non-critical error
			return 1
		// Success
			return 0	
			
	// Add/Delete Store Batch Subprocess
	//	Try to read file "adddeletestore.txt"
        ExistenceCheck
            If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
		Move to record immediately following header
    (A) Process records
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			// Input section
			// If at trailer, proceed to next batch subprogram
			Switch input_line[0]
			// Format of globals for field position & length - <filename>_txt_<actioncode>_<field_name>_pos/len 

			// User enters:  Frank
			// We store:  Frank
			// We evaluate:  FRANK		
			
			std::string input_string
				Case 'A'
					Create an instance of Add_Delete_Store_Event
					Store 'A' action_type in Add_Delete_store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_number_pos,adddeletestore_txt_a_store_number_len) // store_number_length is global designating store_number field length
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store store# in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_address_pos,adddeletestore_txt_a_store_address_len)				
					Store store_address in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_city_name_pos,adddeletestore_txt_a_store_city_name_len)
					Store city_name in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_state_pos,adddeletestore_txt_a_store_state_len)
					if (!ValidateAllLetters(input_string))
						log error "State composed of characters other than letters"
						continue
					Store state in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_zip_pos,adddeletestore_txt_a_store_zip_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store zip in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_a_store_priority_pos,adddeletestore_txt_a_store_priority_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store priority_level in Add_Delete_Store_Event
					Push_back Add_Delete_Store_Event instance to storage vector
				Case 'D'
					Create an instance of Add_Delete_Store_Event
					Store 'D' action_type in Add_Delete_store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_number_pos,adddeletestore_txt_d_store_number_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue								
					Store store# in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_address_pos,adddeletestore_txt_d_store_address_len)			
					Store store_address in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_city_name_pos,adddeletestore_txt_d_store_city_name_len)				
					Store city_name in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_state_pos,adddeletestore_txt_d_store_state_len)
					if (!ValidateAllLetters(input_string))
						log error "State composed of characters other than letters"
						continue
					Store state in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_zip_pos,adddeletestore_txt_d_store_zip_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue							
					Store zip in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_d_store_priority_pos,adddeletestore_txt_d_store_priority_len)
					int store_int = StringToInt(input_string)
					if (store_int < 0 || store_int > 15)
						log error "Priority is negative or greater than 15 on line [curr_item index]"
						continue				
					Store priority_level in Add_Delete_Store_Event
					Push_back Add_Delete_Store_Event instance to storage vector
				Case 'I'
					Create an instance of Add_Delete_Store_Event
					Store 'I' action_type in Add_Delete_store_Event
					input_string = input_line.substr(adddeletestore_txt_i_item_number_pos,adddeletestore_txt_i_item_number_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store item_code in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_i_store_default_quantity_pos,adddeletestore_txt_i_store_default_quantity_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store default_quantity in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_i_store_reorder_level_pos,adddeletestore_txt_i_store_reorder_level_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store reorder_level in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_i_store_reorder_quantity_pos,adddeletestore_txt_i_store_reorder_quantity_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store reorder_quantity in Add_Delete_Store_Event               
					Push_back Add_Delete_Store_Event instance to storage vector
				Case 'C'
					Create an instance of Add_Delete_Store_Event
					Store 'C' action_type in Add_Delete_Store_Event
					input_string = input_line.substr(adddeletestore_txt_c_store_overall_item_count_pos,adddeletestore_txt_c_store_overall_item_count_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue				
					Store store_overall_item_count in Add_Delete_Store_Event
					Push_back Add_Delete_Store_Event instance to storage vector
					Proceed to next record
				Case 'T'
					Read 1 character to nowhere (space)
					//Read 4 characters and store in num_rows
					//Count number of items in table vector
					//If number of items <> num_rows, log error "Trailer row count does not match number of rows" and proceed
				Case default
					Log error "Invalid action code - <givencode>"
				Proceed to next record
        // Cleanup section
		// Process & Cleanup section
					
			CreateFile("addstoreitems.txt", 7)			
			Set item_count to 0							

		returnitems.txt:
			CreateFile("returnfile.txt", 6)
			InsertHeader(returnfile.txt, 6)
		Initialize delete_item_counter to 0
							
		(B) For curr_item = 0 to count of Add_Delete_Store_Event vector items
			
				if item[curr_item].action_type == 'C'
					Log error "'C' record encountered out of sequence"
				else if item[curr_item].action_type == 'I'
					Log error "'I' record encountered out of sequence"				
				else if item[curr_item].action_type == 'D'
					Check if store does not exist
                    If so, log error "Store does not exist" and skip to next line // Use continue			
					Check if store is already deleted (store_status == 'D')
						If so, log error "Store has already been deleted" and skip to next line // Use continue
					Look up store information from store table
					If store_priority != item.store_priority_level
					OR	
					If store_number != item.store_id
					OR
					If street_address != item.street_address
					OR
					If city_name != item.city_name
					OR
					If state_name != item.state_name
					OR
					If zip_code != item.zip_code
						Log error "Data mismatch, deletion aborted"
					Else
						delete_item_counter++
												
						For each item in store_inventory where store_number = curr_item.store_number							
							
							//Create a line in returnitem.txt:
								//Zero-filled vendor number (warehouse_item_data.vendor_number)
								//Zero-filled item code (warehouse_item_data.item_number)
								//Zero-filled quantity (store_inventory.quantity)
							WriteReturnItems(returnitems_txt, vendor_number, item_code, quantity)
								
							Set the item in store_inventory to 'D'							
						Set the item in store_data to 'D'				
														
				else if item[curr_item].action_type == 'A' && store does not exist					
					Create instance of store_data
					Set store_status to C
					Set store_priority to item.store_priority_level
					Set store_number to item.store_id
					Set street_address to item.street_address
					Set city_name to item.city_name
					Set state_name to item.state_name
					Set zip_code to item.zip_code
					Push back instance of store_data to store_data table vector				
					
					If last element
						Log error "Error - End of file reached but no trailer"
						break
					
					Move to next item (curr_item++)
					Reinitialize item_counter to 0
					// I mode
					while item[curr_item].action_type == I && Not past last element					
						item_counter++
						Create instance of store_inventory
						Set store_inventory.item_code to item.item_code
						Set store_inventory.store_default_quantity to item.store_default_quantity
						Set store_inventory.store_reorder_level to item.store_reorder_level
						Set store_inventory.store_reorder_quantity to item.store_reorder_quantity
						Push back store_inventory item to store_inventory table
													
						Write to addstoreitems.txt:
						'A'
						Leading zeroes + store id
						Leading zeroes + store priority level
						Leading zeroes + item code
						Leading zeroes + requested quantity
						Carriage return / nextline
						Move to next item (curr_item++)
					else If (past last element) 
						log error "No corresponding C for A on line [curr_item index]"
						break
					if item[curr_item].action-type == 'C'								
						If C record item count != item_counter Log error "Item count on line [curr_item index] does not match number of items"
					else If (trailer)
						Log error "No corresponding control record <linenumber>"
						break			
					
					// THIS SECTION IS SUPER JANKY SO IF WE FIGURE OUT HOW TO DO IT A DIFFERENT WAY
					// PLEASE DO
					else if item[curr_item].action_type == 'D'
						Log error "<action_type> on <line_number> out of sequence"
						curr_item--
						**[REFERENCE CODE FROM 'D' SECTION ABOVE]**	- REPEAT
					else if item[curr_item].action_type == 'A'
						Log error "<action_type> on <line_number> out of sequence"	
						curr_item--
						
					else If item[curr_item].action_type != 'C'
						Log error "<action_type> on <line_number> out of sequence"
				Else If item[curr_item].action_type == 'A' && store does exist
					log error "Store already exists"
				Else If item[curr_item].action-type == 'T' && !(last element)
					log error "Out of sequence trailer record"
				Else If item[curr_item].action_type == 'T' && (last element)
					log "Done processing adddeletestore.txt"				
				Else
					log error "Invalid action code on line [curr_item index]"
					
				If item[curr_item].action_type != 'T' && (last element)
					log "Error - End of file reached but no trailer"
		
		InsertTrailer(returnitems_txt, delete_item_counter)
		Close and save returnitems.txt
		
		std::sort store_data based on store_priority	
		InsertTrailer(addstoreitems.txt, item_counter)				
		Close and save addstoreitems.txt	
            				
		Proceed to next batch subprogram
		
////// Merge returnfile.txt & vendororder.txt
		// Try to read file "returnitems.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
			
		// Try to read file "vendororder.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
		Create vector of Merge_Add_Online_Batch_Event
		
		Move to record immediately following header for returnitems
		Move to record immediately following header for vendororder
		
    (A) Get input from files
		int item_counter = 0
		
		// Read from returnitems.txt
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			input_string = input_line.substr(returnitems_txt_vendor_code_pos,returnitems_txt_vendor_code_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue			
			Store vendor_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(returnitems_txt_item_code_pos,returnitems_txt_item_code_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue			
			Store item_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(returnitems_txt_incoming_quantity_pos,returnitems_txt_incoming_quantity_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue			
			Store incoming_quantity in Merge_Add_Online_Batch_Event
			item_counter++
		
		// Read from vendororder.txt
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram
				
			std::string input_string
			input_string = input_line.substr(vendororder_txt_vendor_code_pos,vendororder_txt_vendor_code_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
			Store vendor_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(vendororder_txt_item_code_pos,vendororder_txt_item_code_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store item_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(vendororder_txt_incoming_quantity_pos,vendororder_txt_incoming_quantity_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue			
			Store incoming_quantity in Merge_Add_Online_Batch_Event
			item_counter++
					
		CreateFile(itemreceived.txt, 2)
	(B)	For curr_item = 0 to count of Merge_Add_Online_Batch_Event
			Write to file:
						Leading zeroes + vendor_code
						Leading zeroes + item_code
						Leading zeroes + incoming_quantity
						"2017-11-17" (hard-coded string) (DURWIN IS NOT ALLOWED TO CODE THIS SECTION)
						Carriage return / nextline		
		InsertTrailer(itemreceived.txt, item_counter)
		Close itemreceived.txt
		
//// itemreceived.txt Inventory Generation
		
		// Try to read file "itemreceived.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
		Create vector of Merge_Add_Online_Batch_Event
		
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			input_string = input_line.substr(returnitems_txt_vendor_code_pos,returnitems_txt_vendor_code_len) // store_number_length is global designating store_number field length
			Store vendor_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(returnitems_txt_item_code_pos,returnitems_txt_item_code_len) // store_number_length is global designating store_number field length
			Store item_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(returnitems_txt_incoming_quantity_pos,returnitems_txt_incoming_quantity_len) // store_number_length is global designating store_number field length
			Store incoming_quantity in Merge_Add_Online_Batch_Event
			item_counter++	
		
		(B)	For curr_item = 0 to count of Merge_Add_Online_Batch_Event vector items
	
		// Item check
			bool itemFound == false
			For each wh_item in warehouse_item_data
				If item[curr_item].item_number == wh_item.item_number
					If item[curr_item].vendor_number == wh_item.vendor_number
						wh_item.quantity += item[curr_item].quantity
						itemFound = true
						break
					Else
						Log Error "Item <Item> found but vendor number <vendor_number> does not match"		
			If (!itemFound)
				Log Error "Item <Item> not found"
				
		Close itemreceived.txt
		
////// En masse inventory item updates
		//	Try to read file "items.txt"
        ExistenceCheck
            If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
	
		Move to record immediately following header
	
		std::vector<Update_Item_Data_Event> d_event
		std::vector<Update_Item_Data_Event> a_event
		std::vector<Change_Data_Event> c_event
		std::vector<Update_Item_Data_Event> n_event
	
	(A) while(ifstream.good() & !eof)  // While we can read from the file and are not at the end		
			Read a line from file as as a string - input_line
			// Input section
			// If at trailer, proceed to next batch subprogram
			std::string input_string		
			
			Switch input_line[0]
				Case 'D'
					Create an instance of Update_Item_Data_Event
					Store 'D' action_type in Update_Item_Data_Event
					input_string = input_line.substr(items_txt_d_item_number_pos,items_txt_d_item_number_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store item_code in Update_Item_Data_Event instance
					Push_back Update_Item_Data_Event instance to d_event
				Case 'A'
					Store 'A' action_type in Update_Item_Data_Event              
					input_string = input_line.substr(items_txt_a_item_number_pos,items_txt_a_item_number_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store item_code in Update_Item_Data_Event instance				
					input_string = input_line.substr(items_txt_a_item_name_pos,items_txt_a_item_name_len)
					Store item_name in Update_Item_Data_Event instance
					input_string = input_line.substr(items_txt_a_item_description_pos,items_txt_a_item_description_len)
					Store item_description in Update_Item_Data_Event instance
					input_string = input_line.substr(items_txt_a_item_dosage_pos,items_txt_a_item_dosage_len)
					Store item_dosage in Update_Item_Data_Event instance
					input_string = input_line.substr(items_txt_a_warehouse_reorder_level_pos,items_txt_a_warehouse_reorder_level_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store warehouse_reorder_level in Update_Item_Data_Event instance
					input_string = input_line.substr(items_txt_a_vendor_code_pos,items_txt_a_vendor_code_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store vendor_code in Update_Item_Data_Event
					input_string = input_line.substr(items_txt_a_warehouse_reorder_quantity_pos,items_txt_a_warehouse_reorder_quantity_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store warehouse_reorder_quantity in Update_Item_Data_Event
					input_string = input_line.substr(items_txt_a_expected_delivery_time_pos,items_txt_a_expected_delivery_time_len)
					Store expected_delivery_time in Update_Item_Data_Event instance
					Push_back Update_Item_Data_Event instance to a_event
				Case 'C'
					Store 'C' action_type in Change_Data_Event
					input_string = input_line.substr(items_txt_c_item_number_pos,items_txt_c_item_number_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store item_code in Change_Data_Event instance
					input_string = input_line.substr(items_txt_c_item_name_pos,items_txt_c_item_name_len)
					Store item_name in Change_Data_Event instance
					input_string = input_line.substr(items_txt_c_item_description_pos,items_txt_c_item_description_len)
					Store item_description in Change_Data_Event instance
					input_string = input_line.substr(items_txt_c_item_dosage_pos,items_txt_c_item_dosage_len)
					Store item_dosage in Change_Data_Event instance
					input_string = input_line.substr(items_txt_c_warehouse_reorder_level_pos,items_txt_c_warehouse_reorder_level_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store warehouse_reorder_level in Change_Data_Event instance
					input_string = input_line.substr(items_txt_c_vendor_code_pos,items_txt_c_vendor_code_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store vendor_code in Change_Data_Event
					input_string = input_line.substr(items_txt_c_warehouse_reorder_quantity_pos,items_txt_c_warehouse_reorder_quantity_len)
					if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue
					Store warehouse_reorder_quantity in Change_Data_Event
					input_string = input_line.substr(items_txt_c_expected_delivery_time_pos,items_txt_c_expected_delivery_time_len)
					Store expected_delivery_time in Change_Data_Event instance				
					Push_back Change_Data_Event instance to c_event
				Case 'T'
					//Do nothing
					//Read 4 characters and store in num_rows
					//Count number of items in table vector
					//If number of items <> num_rows, log error "Trailer row count does not match number of rows" and proceed
				Case 'N'
					if next character is not D,A or C
						Log Error "Invalid N-type record on line <line>"
						continue
					Store 'N' action_type in Update_Item_Data_Event
					Store specific_action_designation // ie, A records = NA
					input_string = input_line.substr(items_txt_n_update_item_action_count,items_txt_n_update_item_action_count_len) // Specific action count is number following N that indicates the number of records of that specific action
					Store update_item_action_count in Update_Item_Data_Event instance
					Push_back Update_Item_Data_Event instance to n_event
				Case default
					Log error "Invalid action code - <givencode> <linenumber>"			
						
		// ND,NA,NC record count check
				
		int NDcount = -1 
		int NAcount = -1
		int NCcount = -1
		For each Update_Item_Data_Event in n_event
			if n_event.action = 'ND'
				if NDCount != -1
					Log Error "Duplicate ND row detected on line <line>"
				Else
					NDcount = n_event.update_item_action_count
			if n_event.action = 'NA'
				if NAcount != -1
					Log Error "Duplicate NA row detected on line <line>"
				Else
					NAcount = n_event.update_item_action_count
			if n_event.action = 'NC'
				if NCcount != -1
					Log Error "Duplicate NC row detected on line <line>"
				Else
					NCcount = n_event.update_item_action_count
					
		if NDcount == -1 Log Error ("No ND record in file")
		if NAcount == -1 Log Error ("No NA record in file")
		if NCcount == -1 Log Error ("No NC record in file")

		if NDcount != d_event.size()
			Log Error "D record count does not match ND control record count"
		if NAcount != a_event.size()
			Log Error "A record count does not match NA control record count"
		if NCcount != c_event.size()
			Log Error "C record count does not match NC control record count"
		
		// Processing add, delete, change items		
		
		For each item in d_event
			bool returnCode = deleteItemEverywhere(&store_inventory, &warehouse_item_data, item_number)
			if (!returnCode)
				Log Error "Failed to delete item <item_number>"
				
		For each item in a_event
			If (!ItemExists)
				Create an instance of warehouse_item_data
				instance.item_status = 'A'
				instance.item_number = item.item_number
				instance.item_name= item.item_name
				instance.item_description = item.item_description
				instance.item_dosage = item.item_dosage
				instance.reorder_level = item.warehouse_reorder_level
				instance.vendor_number = item.vendor_number
				instance.reorder_quantity = item.warehouse_reorder_quantity
				instance.expected_delivery_time
				instance.quantity
				Push_back instance to warehouse_item_data
			Else
				Log Error ("Item <item_number> already exists, add denied")
		
		For each item in c_event		
		
		// Change - check if item exists
			If (ItemExists(item.item_number))
				int item_index = findWarehouseItem(&warehouse_item_data, item.item_number)				
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].item_name = item.item_name
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].item_description = item.item_description
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].item_dosage = item.item_dosage
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].reorder_level = StringToInt(item.warehouse_reorder_level)
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].vendor_number = StringToInt(item.vendor_number)
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].reorder_quantity = StringToInt(warehouse_reorder_quantity)
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].expected_delivery_time = item.expected_delivery_time
				If !CheckSpaces(item_status, 1) warehouse_item_data[item_index].quantity = StringToInt(item.quantity)							
			Else
				Log Error ("Item <item_number> already exists, change denied")
				
		Close items.txt
		
//// Store automated replenishment (qty <= reorder level) AKA Batch Inventory Review
		
		CreateFile("batchreplenish.txt", 8)		
		InsertHeader(batchreplenish_txt, 8)			
	
		std::vector<store_inventory> store_table (referencing this table)		
		Int item_counter = 0
		
		For each store
			For each item
				If (item.quantity <= item.reorder_level)
					Write:
						'B'
						Zero-filled store.store_number
						Zero-filled store.store_priority
						Zero-filled item.item_number
						Zero-filled item.reorder_quantity					
					item_counter++					
		
		InsertTrailer("batchreplenish.txt" item_counter)
		Close batchreplenish.txt

/// Merge of addstoreitems, batchreplenish, onlineinvrequest
		
	// Try to read file "addstoreitems.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
			
		// Try to read file "batchreplenish.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
			
		// Try to read file "onlineinvrequest.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
		Create vector of Merge_Add_Online_Batch_Event
		
		Move to record immediately following header for addstoreitems
		Move to record immediately following header for batchreplenish
		Move to record immediately following header for onlineinvrequest
    (A) Get input from files
		int item_counter = 0
		
		// Read from addstoreitems.txt
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			Store source_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(addstoreitems_txt_store_number_pos,addstoreitems_txt_store_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(addstoreitems_txt_store_priority_pos,addstoreitems_txt_store_priority_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_priority in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(addstoreitems_txt_item_number_pos,addstoreitems_txt_item_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store item_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(addstoreitems_txt_requested_quantity_pos,addstoreitems_txt_requested_quantity_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store requested_quantity in Merge_Add_Online_Batch_Event
			item_counter++
			
		// Read from batchreplenish.txt
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			Store source_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(batchreplenish_txt_store_number_pos,batchreplenish_txt_store_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(batchreplenish_txt_store_priority_pos,batchreplenish_txt_store_priority_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_priority in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(batchreplenish_txt_item_number_pos,batchreplenish_txt_item_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store item_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(batchreplenish_txt_requested_quantity_pos,batchreplenish_txt_requested_quantity_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store requested_quantity in Merge_Add_Online_Batch_Event
			item_counter++

		// Read from onlineinvrequest.txt
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			Store source_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(onlineinvrequest_txt_store_number_pos,onlineinvrequest_txt_store_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(onlineinvrequest_txt_store_priority_pos,onlineinvrequest_txt_store_priority_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store store_priority in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(onlineinvrequest_txt_item_number_pos,onlineinvrequest_txt_item_number_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store item_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(onlineinvrequest_txt_requested_quantity_pos,onlineinvrequest_txt_requested_quantity_len) // store_number_length is global designating store_number field length
			if (StringToInt(input_string) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store requested_quantity in Merge_Add_Online_Batch_Event
			item_counter++		

		CreateFile(storeupdate.txt, 2)
	(B)	For curr_item = 0 to count of Merge_Add_Online_Batch_Event
			Write to file:
						source_code
						Leading zeroes + store_number
						Leading zeroes + store_priority
						Leading zeroes + item_number
						Leading zeroes + requested_quantity
						Carriage return / nextline		
		InsertTrailer(storeupdate.txt, item_counter)
		Close storeupdate.txt

//// AccuStock

	// Changes reorder_level based on consecutive measurements based on reorder_level
	

	For each item in store_inventory where item.item_number == thing.item_number && item.store_number == thing.store_number
		If item.qty > item.high_threshold
			item.accustock_direction--
		If item.qty < item.low_threshold
			item.accustock_direction++
		if item.accustock_direction == 7
			int increase_amount = 0.1 * (float)item.reorder_quantity
			item.reorder_quantity += increase_amount
			item.accustock_direction = 0
			item.high_threshold += increase_amount
			item.low_threshold += increase_amount
		if item.accustock_direction == -7
			int decrease_amount = 0.1 * (float)item.reorder_quantity
			item.reorder_quantity -= increase_amount
			item.accustock_direction = 0
			item.high_threshold -= increase_amount
			item.low_threshold -= increase_amount	
		
//// Inventory processing of merged batchreplenish, addstoreitems, onlineinvrequest files
//// Store inventory generation
	
	// Try to read file "storeupdate.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
		Create vector of Merge_Add_Online_Batch_Event
		
		while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			std::string input_string
			input_string = input_line.substr(storeupdate_txt_source_code_pos,storeupdate_txt_source_code_len) // store_number_length is global designating store_number field length
			Store source_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(storeupdate_txt_store_number_pos,storeupdate_store_number_code_len) // store_number_length is global designating store_number field length
			Store store_number in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(storeupdate_txt_store_priority_pos,storeupdate_txt_store_priority_len) // store_number_length is global designating store_number field length
			Store store_priority in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(storeupdate_txt_item_code_pos,storeupdate_txt_item_code_len) // store_number_length is global designating store_number field length
			Store item_code in Merge_Add_Online_Batch_Event
			input_string = input_line.substr(storeupdate_txt_requested_quantity_pos,storeupdate_txt_requested_quantity_len) // store_number_length is global designating store_number field length
			Store requested_quantity in Merge_Add_Online_Batch_Event
		
		(B)	For curr_item = 0 to count of Merge_Add_Online_Batch_Event vector items				
				int store_index = FindStore(store_data, int store_number)				
				if (store_index == -1)
					Log Error "Store <store_number> does not exist"
					continue
				int store_item_index = FindStoreItem(store_inventory, int item_number)
				if (store_item_index == -1)
					Log Error "Item <item_number> does not exist at store <store_number>"
					continue
				if (store_data[store_index].store_priority != item.priority)
					Log Error "Item <item_number> priority does not match store <store_number>'s"
					continue
				store_inventory[store_item_index].quantity = item.quantity
				
		Close storeupdate.txt
	
////  Vendor order generation (Request more inventory)

	CreateFile("vendorrequest.txt", 8)		
	InsertHeader(vendorrequest_txt, 8)			

	std::vector<warehouse_item_data> wh_table (referencing this table)		
	Int item_counter = 0	
	
	For each item
		If (item.quantity <= item.reorder_level)
			Write:				
				Zero-filled item.vendor_number
				Zero-filled item.item_number
				Zero-filled item.reorder_quantity
			item_counter++					

	InsertTrailer("batchreplenish.txt" item_counter)
	Close vendorrequest.txt

//// Yearly Sales Report generation

	// Try to read file "reports.txt"
		    If file does not exist, log & proceed to next batch subprogram
        HeaderCheck
            If header is bad proceed to next subprogram
			//	First two characters != 'HD'
			//	Third character != <space>				
			// Then log error "Header read failed" & proceed to next batch subprogram				
		SequenceCheck
			If out of sequence proceed to next batch subprogram
			//If out of sequence, log error "<Batch job name> <Filename> Sequence validation failed, expected [stored_num] but encountered [file_num] " 
			//& proceed to next batch subprogram
            //sequence_numbers[adddeletestore] = <filesequencenumber>                
        TrailerCheck
			If no rows in file 
				UpdateSequenceNumber()
				proceed to next batch subprogram
			If issue reading trailer log error
            //If next line is trailer & trailer says 0 rows, log "Empty file", update sequence number (adddeletestore.txt) & proceed to next batch subprogram
            //If next line is trailer & trailer says >0 rows, log error "Trailer row count mismatch, trailer says [trailer_rows] & [file_rows] in file" & proceed to next batch subprogram
            // Read rows until trailer row, store in num_rows  // Unnecessary? (Case 'T' has same functionality)
		
	std::vector<int> report_items
	while(ifstream.good() & !eof)  // While we can read from the file and are not at the end
			Read a line from file as as a string - input_line
			
			// Input section
			// If at trailer, proceed to next batch subprogram				
			
			if (StringToInt(input_line) < 0)
						log error "Store number is negative on line [curr_item index]"
						continue		
			Store input_line in report_items
	
	
StartDate - EndDate
		Item: <ItemNumber>
			2015
				Jan
				Feb
				Mar
				.
				.
				.
			Total: Jan + Feb + Mar + ...
			2016
				Jan
				Feb
				Mar
				.
				.
				.
			Total: Jan + Feb + Mar + ...
			2017
				Jan
				Feb
				Mar
				.
				.
				.
			Total: Jan + Feb + Mar + ...
			
		Grand Total:  ... + 2015 + 2016 + 2017
		// Print item number
		// Print year of first entry for item number
		// Print month of first entry for item number
			// When month changes print month for that entry
			// When year changes 
				Print total for that year
				Print year for that entry
		// Print grand total
			
		
	
2017041501

			
			
	
